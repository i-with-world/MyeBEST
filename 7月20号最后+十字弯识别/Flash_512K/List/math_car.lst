###############################################################################
#                                                                             #
#                                                       22/Jul/2015  10:59:26 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\math_car.c  #
#    Command line =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\math_car.c  #
#                    -D IAR -lCN C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð #
#                    \Flash_512K\List\ -lB C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+ #
#                    Ê®×ÖÍäÊ¶±ð\Flash_512K\List\ -o                           #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    Obj\ --no_cse --no_unroll --no_inline --no_code_motion   #
#                    --no_tbaa --no_clustering --no_scheduling --debug        #
#                    --endian=little --cpu=Cortex-M4 -e --char_is_signed      #
#                    --fpu=None --dlib_config "C:\Program Files\IAR           #
#                    Systems\Embedded Workbench 6.0                           #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\CPU #
#                    \ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Librar #
#                    y\Drivers\ADC\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×Ö #
#                    ÍäÊ¶±ð\Library\Drivers\FTM\ -I                           #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Dri #
#                    vers\GPIO\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶ #
#                    ±ð\Library\Drivers\PIT\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ #
#                    ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Drivers\I2C\ -I                  #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Dri #
#                    vers\UART\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶ #
#                    ±ð\Library\Drivers\FTFL\ -I                              #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\MyFunction\ #
#                     -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\SD_Syst #
#                    em\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Dela #
#                    y\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Syste #
#                    m_Init\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\ #
#                    OLED\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\ZL #
#                    G7290\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\S #
#                    imple_AD\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶± #
#                    ð\Make_Desicion\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê® #
#                    ×ÖÍäÊ¶±ð\Make_Desicion\Judge_Way\ -I                     #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Make_Desici #
#                    on\Speed_Control\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê #
#                    ®×ÖÍäÊ¶±ð\Source\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê #
#                    ®×ÖÍäÊ¶±ð\Peripheral_Oparation\ -I                       #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Balance_con #
#                    trol\ -Ol                                                #
#    List file    =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    List\math_car.lst                                        #
#    Object file  =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    Obj\math_car.o                                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\math_car.c
      1          #include "AllHeaders.h"
      2          #include "math_car.h"
      3          

   \                                 In section .text, align 2, keep-with-next
      4          inline int16s_t abs_int16s(int16s_t num)
      5          {
      6            if(num < 0)
   \                     abs_int16s:
   \   00000000   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD503             BPL.N    ??abs_int16s_0
      7              return (-num);
   \   00000006   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   00000008   0x4240             RSBS     R0,R0,#+0
   \   0000000A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000000C   0xE000             B.N      ??abs_int16s_1
      8            else
      9              return num;
   \                     ??abs_int16s_0:
   \   0000000E   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \                     ??abs_int16s_1:
   \   00000010   0x4770             BX       LR               ;; return
     10          }
     11          
     12          
     13          /*
     14          inline int8u_t JudgeValid(int16s_t pointer, const int8u_t* edgeArr)
     15          {
     16            int16s_t p_last, p_past, p_next, p_2nd;
     17            
     18            p_last = pointer - 1;
     19            if(p_last <0)
     20              p_last = EAGEARRLEN - 1;
     21            p_past = p_last - 1;
     22            if(p_past <0)
     23              p_past = EAGEARRLEN - 1;
     24            p_next = pointer + 1;
     25            if(p_next >= EAGEARRLEN)
     26              p_next = 0;
     27            p_2nd = p_next + 1;
     28            if(p_2nd >= EAGEARRLEN)
     29              p_2nd = 0;
     30            
     31            if(abs_int16s(edgeArr[pointer] - edgeArr[p_last]) < VALIDLIMIT
     32               &&abs_int16s(edgeArr[p_last] - edgeArr[p_past]) < VALIDLIMIT
     33                 &&abs_int16s(edgeArr[pointer] - edgeArr[p_next]) < VALIDLIMIT
     34                   &&abs_int16s(edgeArr[p_next] - edgeArr[p_2nd]) < VALIDLIMIT)
     35              return 1;
     36            else
     37              return 0;
     38          }  */
     39          
     40          
     41          /************************************************************************************************ 
     42          * CalculateSlope
     43          * ÀûÓÃ×îÐ¡¶þ³Ë·¨ÇóÒ»¶ÎÍ¼ÏñµÄÐ±ÂÊ(*10À©Õ¹)
     44          * Èë¿Ú²ÎÊý  x_start:ÆðÊ¼ÐÐ2Êý(µÚÒ»¸ö²ÎÓë¼ÆËãÐÐµÄÏÂ±ê)
     45                      x_end:ÖÕÖ¹º¯Êý(×îºóÒ»¸ö²ÎÓë¼ÆËãÐÐµÄÏÂ±ê)
     46                      y:´æ·Å¸÷ÐÐÇúÏß×ø±êÖµÊý×é(16Î»±äÁ¿)
     47                      Valid:´æ·Å¸÷ÐÐÓÐÐ§ÐÔ±êÖ¾µÄÊý×é(!!!8Î»±äÁ¿) 
     48          * ·µ»Ø²ÎÊý  ÇúÏßÐ±ÂÊ(*10À©Õ¹)   
     49          ************************************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     50          int16s_t CalculateSlope(int8u_t x_start ,int8u_t x_num ,const int8u_t *y,const int8u_t *valid)
     51          {
   \                     CalculateSlope:
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
     52            int16s_t n=0, num = 0;
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xF05F 0x0C00      MOVS     R12,#+0
     53            int32s_t x_sum=0;
   \   0000000A   0x2500             MOVS     R5,#+0
     54            int32s_t y_sum=0;
   \   0000000C   0x2600             MOVS     R6,#+0
     55            int32s_t xy_sum=0;
   \   0000000E   0x2700             MOVS     R7,#+0
     56            int32s_t x2_sum=0;
   \   00000010   0xF05F 0x0E00      MOVS     LR,#+0
     57            int32s_t tmp;                        
     58           
     59            if(x_num > EAGEARRLEN)
   \   00000014   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000016   0x291F             CMP      R1,#+31
   \   00000018   0xD326             BCC.N    ??CalculateSlope_0
     60              x_num = EAGEARRLEN;
   \   0000001A   0x211E             MOVS     R1,#+30
   \   0000001C   0xE024             B.N      ??CalculateSlope_0
     61            for(;num<x_num;x_start++)
     62            {
     63              num++;
   \                     ??CalculateSlope_1:
   \   0000001E   0xF11C 0x0C01      ADDS     R12,R12,#+1
     64              if(x_start >= EAGEARRLEN)
   \   00000022   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000024   0x281E             CMP      R0,#+30
   \   00000026   0xD300             BCC.N    ??CalculateSlope_2
     65                x_start = 0;
   \   00000028   0x2000             MOVS     R0,#+0
     66              if((valid[x_start] != 0)&&(y[x_start])) 
   \                     ??CalculateSlope_2:
   \   0000002A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000002C   0xF810 0x8003      LDRB     R8,[R0, R3]
   \   00000030   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000034   0xD017             BEQ.N    ??CalculateSlope_3
   \   00000036   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000038   0xF810 0x8002      LDRB     R8,[R0, R2]
   \   0000003C   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000040   0xD011             BEQ.N    ??CalculateSlope_3
     67              {
     68                x_sum += x_start;
   \   00000042   0xFA55 0xF580      UXTAB    R5,R5,R0
     69                y_sum += y[x_start];
   \   00000046   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000048   0xF810 0x8002      LDRB     R8,[R0, R2]
   \   0000004C   0xEB16 0x0608      ADDS     R6,R6,R8
     70                x2_sum += x_start*x_start;
   \   00000050   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000052   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000054   0xFB00 0xEE00      MLA      LR,R0,R0,LR
     71                xy_sum += x_start*y[x_start];
   \   00000058   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000005C   0xF810 0x8002      LDRB     R8,[R0, R2]
   \   00000060   0xFB08 0x7700      MLA      R7,R8,R0,R7
     72                
     73                n++;
   \   00000064   0x1C64             ADDS     R4,R4,#+1
     74              }
     75            }
   \                     ??CalculateSlope_3:
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \                     ??CalculateSlope_0:
   \   00000068   0x4688             MOV      R8,R1
   \   0000006A   0xFA5F 0xF888      UXTB     R8,R8            ;; ZeroExt  R8,R8,#+24,#+24
   \   0000006E   0xFA0F 0xFC8C      SXTH     R12,R12          ;; SignExt  R12,R12,#+16,#+16
   \   00000072   0xFA0F 0xF888      SXTH     R8,R8            ;; SignExt  R8,R8,#+16,#+16
   \   00000076   0x45C4             CMP      R12,R8
   \   00000078   0xDBD1             BLT.N    ??CalculateSlope_1
     76              
     77            
     78            tmp=n*x2_sum-x_sum*x_sum;
   \   0000007A   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000007C   0xFB0E 0xF004      MUL      R0,LR,R4
   \   00000080   0xFB05 0x0015      MLS      R0,R5,R5,R0
     79            if(tmp != 0)
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD00A             BEQ.N    ??CalculateSlope_4
     80            {
     81              return (int16s_t)(100*(n*xy_sum-x_sum*y_sum)/tmp); 
   \   00000088   0xB224             SXTH     R4,R4            ;; SignExt  R4,R4,#+16,#+16
   \   0000008A   0xFB07 0xF104      MUL      R1,R7,R4
   \   0000008E   0xFB06 0x1115      MLS      R1,R6,R5,R1
   \   00000092   0x2264             MOVS     R2,#+100
   \   00000094   0x4351             MULS     R1,R2,R1
   \   00000096   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   0000009A   0xB200             SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
   \   0000009C   0xE000             B.N      ??CalculateSlope_5
     82            }
     83            else
     84            {
     85              return 0;
   \                     ??CalculateSlope_4:
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??CalculateSlope_5:
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
     86            }
     87          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  CalculateSlope
        0  abs_int16s


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     164  CalculateSlope
      18  abs_int16s

 
 182 bytes in section .text
 
 182 bytes of CODE memory

Errors: none
Warnings: none
