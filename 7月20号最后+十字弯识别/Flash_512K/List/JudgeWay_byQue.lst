###############################################################################
#                                                                             #
#                                                       22/Jul/2015  10:59:26 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Make_Desici #
#                    on\Judge_Way\JudgeWay_byQue.c                            #
#    Command line =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Make_Desici #
#                    on\Judge_Way\JudgeWay_byQue.c -D IAR -lCN                #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    List\ -lB C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\F #
#                    lash_512K\List\ -o C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®× #
#                    ÖÍäÊ¶±ð\Flash_512K\Obj\ --no_cse --no_unroll             #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --char_is_signed --fpu=None --dlib_config             #
#                    "C:\Program Files\IAR Systems\Embedded Workbench 6.0     #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\CPU #
#                    \ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Librar #
#                    y\Drivers\ADC\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×Ö #
#                    ÍäÊ¶±ð\Library\Drivers\FTM\ -I                           #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Dri #
#                    vers\GPIO\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶ #
#                    ±ð\Library\Drivers\PIT\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ #
#                    ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Drivers\I2C\ -I                  #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Library\Dri #
#                    vers\UART\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶ #
#                    ±ð\Library\Drivers\FTFL\ -I                              #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\MyFunction\ #
#                     -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\SD_Syst #
#                    em\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Dela #
#                    y\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Syste #
#                    m_Init\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\ #
#                    OLED\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\ZL #
#                    G7290\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\S #
#                    imple_AD\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶± #
#                    ð\Make_Desicion\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê® #
#                    ×ÖÍäÊ¶±ð\Make_Desicion\Judge_Way\ -I                     #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Make_Desici #
#                    on\Speed_Control\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê #
#                    ®×ÖÍäÊ¶±ð\Source\ -I C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê #
#                    ®×ÖÍäÊ¶±ð\Peripheral_Oparation\ -I                       #
#                    C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Balance_con #
#                    trol\ -Ol                                                #
#    List file    =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    List\JudgeWay_byQue.lst                                  #
#    Object file  =  C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Flash_512K\ #
#                    Obj\JudgeWay_byQue.o                                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\dong\Desktop\7ÔÂ20ºÅ×îºó+Ê®×ÖÍäÊ¶±ð\Make_Desicion\Judge_Way\JudgeWay_byQue.c
      1          #include "AllHeaders.h"
      2          

   \                                 In section .bss, align 4
      3          int gyroArr[MAXARR] = {0};
   \                     gyroArr:
   \   00000000                      DS8 400

   \                                 In section .data, align 4
      4          QueByArr gyroQue = {gyroArr, 0, 0, 0, 0};
   \                     gyroQue:
   \   00000000   0x........         DC32 gyroArr, 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   

   \                                 In section .bss, align 4
      5          int pathType = UNKONWN;     //ÈüµÀÀàÐÍ±äÁ¿
   \                     pathType:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
      6          int judgeWayLen;      //ÅÐ¶ÏÈüµÀËùÓÃÊý¾Ý³¤¶È
   \                     judgeWayLen:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
      7          int averGyroVal;      //ÍÓÂÝÒÇ²ÉÖµÆ½¾ù
   \                     averGyroVal:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
      8          int gyroData;   //ÍÓÂÝÒÇÊý¾Ý
   \                     gyroData:
   \   00000000                      DS8 4
      9          

   \                                 In section .text, align 2, keep-with-next
     10          int abs_int(int num)
     11          {
     12            if(num < 0)
   \                     abs_int:
   \   00000000   0x2800             CMP      R0,#+0
   \   00000002   0xD501             BPL.N    ??abs_int_0
     13              return (-num);
   \   00000004   0x4240             RSBS     R0,R0,#+0
   \   00000006   0xE7FF             B.N      ??abs_int_1
     14            else
     15              return num;
   \                     ??abs_int_0:
   \                     ??abs_int_1:
   \   00000008   0x4770             BX       LR               ;; return
     16          }
     17          

   \                                 In section .text, align 2, keep-with-next
     18          static void PushInt(int data, QueByArr* que)
     19          {
     20            if(que->size < MAXARR)   //Èç¹û¶ÓÁÐ³¤¶ÈÐ¡ÓÚ×î´ó³¤¶È
   \                     PushInt:
   \   00000000   0x684A             LDR      R2,[R1, #+4]
   \   00000002   0x2A64             CMP      R2,#+100
   \   00000004   0xDA17             BGE.N    ??PushInt_0
     21            {
     22              if(que->lastPos < MAXARR-1)    //Èç¹û¶ÓÎ²ÔÚÊý×éÖÐ¼ä
   \   00000006   0x690A             LDR      R2,[R1, #+16]
   \   00000008   0x2A63             CMP      R2,#+99
   \   0000000A   0xDA07             BGE.N    ??PushInt_1
     23              {
     24                que->queArr[que->lastPos] = data;
   \   0000000C   0x690A             LDR      R2,[R1, #+16]
   \   0000000E   0x680B             LDR      R3,[R1, #+0]
   \   00000010   0xF843 0x0022      STR      R0,[R3, R2, LSL #+2]
     25                que->lastPos++;
   \   00000014   0x690A             LDR      R2,[R1, #+16]
   \   00000016   0x1C52             ADDS     R2,R2,#+1
   \   00000018   0x610A             STR      R2,[R1, #+16]
   \   0000001A   0xE008             B.N      ??PushInt_2
     26              }
     27              else if(que->lastPos == MAXARR-1)    //Èç¹û¶ÓÎ²ÔÚÊý×éÎ²¶Ë
   \                     ??PushInt_1:
   \   0000001C   0x690A             LDR      R2,[R1, #+16]
   \   0000001E   0x2A63             CMP      R2,#+99
   \   00000020   0xD105             BNE.N    ??PushInt_2
     28              {
     29                que->queArr[que->lastPos] = data;
   \   00000022   0x690A             LDR      R2,[R1, #+16]
   \   00000024   0x680B             LDR      R3,[R1, #+0]
   \   00000026   0xF843 0x0022      STR      R0,[R3, R2, LSL #+2]
     30                  que->lastPos = 0;
   \   0000002A   0x2200             MOVS     R2,#+0
   \   0000002C   0x610A             STR      R2,[R1, #+16]
     31              }
     32              que->size++;
   \                     ??PushInt_2:
   \   0000002E   0x684A             LDR      R2,[R1, #+4]
   \   00000030   0x1C52             ADDS     R2,R2,#+1
   \   00000032   0x604A             STR      R2,[R1, #+4]
   \   00000034   0xE009             B.N      ??PushInt_3
     33            }
     34            else
     35            {
     36              que->queArr[que->lastPos] = data;
   \                     ??PushInt_0:
   \   00000036   0x690A             LDR      R2,[R1, #+16]
   \   00000038   0x680B             LDR      R3,[R1, #+0]
   \   0000003A   0xF843 0x0022      STR      R0,[R3, R2, LSL #+2]
     37              que->lastPos++;
   \   0000003E   0x690A             LDR      R2,[R1, #+16]
   \   00000040   0x1C52             ADDS     R2,R2,#+1
   \   00000042   0x610A             STR      R2,[R1, #+16]
     38              que->firstPos++;
   \   00000044   0x68CA             LDR      R2,[R1, #+12]
   \   00000046   0x1C52             ADDS     R2,R2,#+1
   \   00000048   0x60CA             STR      R2,[R1, #+12]
     39            }
     40            que->totle += data;
   \                     ??PushInt_3:
   \   0000004A   0x688A             LDR      R2,[R1, #+8]
   \   0000004C   0x1880             ADDS     R0,R0,R2
   \   0000004E   0x6088             STR      R0,[R1, #+8]
     41          }
   \   00000050   0x4770             BX       LR               ;; return
     42          

   \                                 In section .text, align 2, keep-with-next
     43          static void PopInt(int num, QueByArr* que)
     44          {
   \                     PopInt:
   \   00000000   0xB430             PUSH     {R4,R5}
     45            int i;
     46            
     47            if(num < que->size)    //Èç¹ûµ¯³ö¸öÊýÐ¡ÓÚ¶ÓÁÐ³¤¶È
   \   00000002   0x684A             LDR      R2,[R1, #+4]
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xDA18             BGE.N    ??PopInt_0
     48            {
     49              for(i=0;i<num;i++)
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xE002             B.N      ??PopInt_1
     50              {
     51                que->totle -= que->queArr[que->firstPos];
     52                if(que->firstPos < MAXARR-1)
     53                {
     54                  que->firstPos++;
     55                }
     56                else
     57                {
     58                  que->firstPos = 0;
   \                     ??PopInt_2:
   \   0000000C   0x2300             MOVS     R3,#+0
   \   0000000E   0x60CB             STR      R3,[R1, #+12]
     59                }
   \                     ??PopInt_3:
   \   00000010   0x1C52             ADDS     R2,R2,#+1
   \                     ??PopInt_1:
   \   00000012   0x4282             CMP      R2,R0
   \   00000014   0xDA0D             BGE.N    ??PopInt_4
   \   00000016   0x688B             LDR      R3,[R1, #+8]
   \   00000018   0x68CC             LDR      R4,[R1, #+12]
   \   0000001A   0x680D             LDR      R5,[R1, #+0]
   \   0000001C   0xF855 0x4024      LDR      R4,[R5, R4, LSL #+2]
   \   00000020   0x1B1B             SUBS     R3,R3,R4
   \   00000022   0x608B             STR      R3,[R1, #+8]
   \   00000024   0x68CB             LDR      R3,[R1, #+12]
   \   00000026   0x2B63             CMP      R3,#+99
   \   00000028   0xDAF0             BGE.N    ??PopInt_2
   \   0000002A   0x68CB             LDR      R3,[R1, #+12]
   \   0000002C   0x1C5B             ADDS     R3,R3,#+1
   \   0000002E   0x60CB             STR      R3,[R1, #+12]
   \   00000030   0xE7EE             B.N      ??PopInt_3
     60              }
     61              que->size -= num;
   \                     ??PopInt_4:
   \   00000032   0x684A             LDR      R2,[R1, #+4]
   \   00000034   0x1A10             SUBS     R0,R2,R0
   \   00000036   0x6048             STR      R0,[R1, #+4]
   \   00000038   0xE007             B.N      ??PopInt_5
     62          
     63            }
     64            else
     65            {
     66              que->firstPos = 0;
   \                     ??PopInt_0:
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x60C8             STR      R0,[R1, #+12]
     67              que->lastPos = 0;
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x6108             STR      R0,[R1, #+16]
     68              que->size = 0;
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6048             STR      R0,[R1, #+4]
     69              que->totle = 0;
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0x6088             STR      R0,[R1, #+8]
     70            }
     71          }
   \                     ??PopInt_5:
   \   0000004A   0xBC30             POP      {R4,R5}
   \   0000004C   0x4770             BX       LR               ;; return
     72           
     73          static int FrontOf(QueByArr* que)
     74          {
     75            return (que->queArr[que->firstPos]);
     76          }
     77          
     78          static int BackOf(QueByArr* que)
     79          {
     80            return (que->queArr[que->lastPos - 1]);
     81          }
     82          

   \                                 In section .text, align 2, keep-with-next
     83          void JudgeWay(int gyroData)
     84          {
   \                     JudgeWay:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
     85            if(pathType == UNKONWN)   //ÏÈ¾ö¶¨¶ÓÁÐ³¤¶È
   \   00000004   0x....             LDR.N    R0,??DataTable0
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??JudgeWay_0
     86            {
     87              judgeWayLen = JUDGELEN;
   \   0000000C   0x....             LDR.N    R0,??DataTable0_1
   \   0000000E   0x2128             MOVS     R1,#+40
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0xE002             B.N      ??JudgeWay_1
     88            }
     89            else
     90              judgeWayLen = NORMALLEN;
   \                     ??JudgeWay_0:
   \   00000014   0x....             LDR.N    R0,??DataTable0_1
   \   00000016   0x2114             MOVS     R1,#+20
   \   00000018   0x6001             STR      R1,[R0, #+0]
     91            //ÔÙ½øÐÐÑ¹¶ÓÁÐ³ö¶ÓÁÐ²Ù×÷
     92            if(gyroQue.size < judgeWayLen)
   \                     ??JudgeWay_1:
   \   0000001A   0x....             LDR.N    R0,??DataTable0_2
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x....             LDR.N    R1,??DataTable0_1
   \   00000020   0x6809             LDR      R1,[R1, #+0]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xDA06             BGE.N    ??JudgeWay_2
     93              PushInt(abs_int(gyroData), &gyroQue);
   \   00000026   0x0020             MOVS     R0,R4
   \   00000028   0x.... 0x....      BL       abs_int
   \   0000002C   0x....             LDR.N    R1,??DataTable0_2
   \   0000002E   0x.... 0x....      BL       PushInt
   \   00000032   0xE011             B.N      ??JudgeWay_3
     94            else
     95            {
     96              PopInt(gyroQue.size - judgeWayLen, &gyroQue);
   \                     ??JudgeWay_2:
   \   00000034   0x....             LDR.N    R1,??DataTable0_2
   \   00000036   0x....             LDR.N    R0,??DataTable0_2
   \   00000038   0x6840             LDR      R0,[R0, #+4]
   \   0000003A   0x....             LDR.N    R2,??DataTable0_1
   \   0000003C   0x6812             LDR      R2,[R2, #+0]
   \   0000003E   0x1A80             SUBS     R0,R0,R2
   \   00000040   0x.... 0x....      BL       PopInt
     97              PushInt(abs_int(gyroData), &gyroQue);
   \   00000044   0x0020             MOVS     R0,R4
   \   00000046   0x.... 0x....      BL       abs_int
   \   0000004A   0x....             LDR.N    R1,??DataTable0_2
   \   0000004C   0x.... 0x....      BL       PushInt
     98              PopInt(1, &gyroQue);
   \   00000050   0x....             LDR.N    R1,??DataTable0_2
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       PopInt
     99            }
    100            averGyroVal = gyroQue.totle / gyroQue.size;
   \                     ??JudgeWay_3:
   \   00000058   0x....             LDR.N    R0,??DataTable0_2
   \   0000005A   0x6880             LDR      R0,[R0, #+8]
   \   0000005C   0x....             LDR.N    R1,??DataTable0_2
   \   0000005E   0x6849             LDR      R1,[R1, #+4]
   \   00000060   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000064   0x....             LDR.N    R1,??DataTable0_3
   \   00000066   0x6008             STR      R0,[R1, #+0]
    101            //ÔÙ½øÐÐÈüµÀÊ¶±ð
    102            if(pathType == UNKONWN)     //Èç¹ûÈüµÀÀàÐÍÎ´Öª
   \   00000068   0x....             LDR.N    R0,??DataTable0
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD111             BNE.N    ??JudgeWay_4
    103            {
    104              if(gyroQue.size >= judgeWayLen)   //Ö»ÓÐ¶ÓÁÐ³¤¶È×ã¹»³¤²Å»á¶ÔÈüµÀ½øÐÐÅÐ¶Ï
   \   00000070   0x....             LDR.N    R0,??DataTable0_2
   \   00000072   0x6840             LDR      R0,[R0, #+4]
   \   00000074   0x....             LDR.N    R1,??DataTable0_1
   \   00000076   0x6809             LDR      R1,[R1, #+0]
   \   00000078   0x4288             CMP      R0,R1
   \   0000007A   0xDB22             BLT.N    ??JudgeWay_5
    105              {
    106                if(averGyroVal > TURNLEFTLIM)
   \   0000007C   0x....             LDR.N    R0,??DataTable0_3
   \   0000007E   0x6800             LDR      R0,[R0, #+0]
   \   00000080   0x28C9             CMP      R0,#+201
   \   00000082   0xDB03             BLT.N    ??JudgeWay_6
    107                  pathType = LBENDPATH;
   \   00000084   0x....             LDR.N    R0,??DataTable0
   \   00000086   0x2102             MOVS     R1,#+2
   \   00000088   0x6001             STR      R1,[R0, #+0]
   \   0000008A   0xE01A             B.N      ??JudgeWay_5
    108                else
    109                  pathType = STRGPATH;
   \                     ??JudgeWay_6:
   \   0000008C   0x....             LDR.N    R0,??DataTable0
   \   0000008E   0x2101             MOVS     R1,#+1
   \   00000090   0x6001             STR      R1,[R0, #+0]
   \   00000092   0xE016             B.N      ??JudgeWay_5
    110              }
    111            }
    112            else if(pathType == STRGPATH)    //Èç¹ûÔÚÖ±µÀÉÏ
   \                     ??JudgeWay_4:
   \   00000094   0x....             LDR.N    R0,??DataTable0
   \   00000096   0x6800             LDR      R0,[R0, #+0]
   \   00000098   0x2801             CMP      R0,#+1
   \   0000009A   0xD107             BNE.N    ??JudgeWay_7
    113            {
    114              if(averGyroVal > TURNLEFTLIM)
   \   0000009C   0x....             LDR.N    R0,??DataTable0_3
   \   0000009E   0x6800             LDR      R0,[R0, #+0]
   \   000000A0   0x28C9             CMP      R0,#+201
   \   000000A2   0xDB0E             BLT.N    ??JudgeWay_5
    115                pathType = UNKONWN;
   \   000000A4   0x....             LDR.N    R0,??DataTable0
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x6001             STR      R1,[R0, #+0]
   \   000000AA   0xE00A             B.N      ??JudgeWay_5
    116            }
    117            else if(pathType == LBENDPATH)    //Èç¹ûÔÚ×ó×ªÍäµÀÉÏ
   \                     ??JudgeWay_7:
   \   000000AC   0x....             LDR.N    R0,??DataTable0
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x2802             CMP      R0,#+2
   \   000000B2   0xD106             BNE.N    ??JudgeWay_5
    118            {
    119              if(averGyroVal < TURNLEFTLIM)
   \   000000B4   0x....             LDR.N    R0,??DataTable0_3
   \   000000B6   0x6800             LDR      R0,[R0, #+0]
   \   000000B8   0x28C8             CMP      R0,#+200
   \   000000BA   0xDA02             BGE.N    ??JudgeWay_5
    120                pathType = UNKONWN;
   \   000000BC   0x....             LDR.N    R0,??DataTable0
   \   000000BE   0x2100             MOVS     R1,#+0
   \   000000C0   0x6001             STR      R1,[R0, #+0]
    121            }
    122            //µ÷ÊÔ³ÌÐò
    123          //  if(pathType == STRGPATH)
    124          //    ONBUZZER();
    125          //  else
    126          //    OFFBUZZER();
    127          }
   \                     ??JudgeWay_5:
   \   000000C2   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     pathType

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_1:
   \   00000000   0x........         DC32     judgeWayLen

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_2:
   \   00000000   0x........         DC32     gyroQue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0_3:
   \   00000000   0x........         DC32     averGyroVal

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  JudgeWay
             8 -> PopInt
             8 -> PushInt
             8 -> abs_int
        8  PopInt
        0  PushInt
        0  abs_int


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
     196  JudgeWay
      78  PopInt
      82  PushInt
      10  abs_int
       4  averGyroVal
     400  gyroArr
       4  gyroData
      20  gyroQue
       4  judgeWayLen
       4  pathType

 
 416 bytes in section .bss
  20 bytes in section .data
 382 bytes in section .text
 
 382 bytes of CODE memory
 436 bytes of DATA memory

Errors: none
Warnings: 2
