///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      10/Jan/2013  19:05:36 /
// IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM               /
// Copyright 1999-2012 IAR Systems AB.                                        /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \Drivers\ADC\adc.c                                      /
//    Command line =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \Drivers\ADC\adc.c -D IAR -lCN                          /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\L /
//                    ist\ -lB E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ /
//                    \µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0. /
//                    3\Debug\List\ -o E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ /
//                    °Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\201301 /
//                    10\V0.0.3\Debug\Obj\ --no_cse --no_unroll --no_inline   /
//                    --no_code_motion --no_tbaa --no_clustering              /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=Cortex-M4 -e --fpu=None --dlib_config             /
//                    D:\Tools\IAR6.30\arm\INC\c\DLib_Config_Normal.h -I      /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \CPU\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ /
//                    \µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0. /
//                    3\Library\Drivers\ADC\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ /
//                    ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ /
//                    ÓÃ\20130110\V0.0.3\Library\Drivers\FTM\ -I              /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \Drivers\GPIO\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µ /
//                    Ú°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130 /
//                    110\V0.0.3\Library\Drivers\PIT\ -Ol                     /
//    List file    =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\L /
//                    ist\adc.s                                               /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME `adc`

        #define SHT_PROGBITS 0x1

        EXTERN EnableInt_Kinetis
        EXTERN SetIntPri_Kinetis

        PUBLIC ADC_ClockCtrl
        PUBLIC ADC_SetCFG1
        PUBLIC ADC_SetCFG2
        PUBLIC ADC_SetSC
        PUBLIC ADC_readResult

// E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\Drivers\ADC\adc.c
//    1 /*******************************************************************************
//    2 * ÎÄ¼þÃû³Æ£ºadc.c
//    3 * Ãè    Êö: ADCÇý¶¯³ÌÐò,²¢Ã»ÓÐ½«¶ÔÓ¦µÄÒý½ÅÉèÎªAD¹¦ÄÜ£¨²Î¿¼¼Í³ÉÊ¦ÐÖÇý¶¯³ÌÐò£©
//    4 * ×÷    Õß£ºÍò±ù±ù
//    5 * ÌØ±ðÃùÐ»£º¼Í³ÉÊ¦ÐÖ(²©¿Íhttp://blog.chinaaet.com/jihceng0622)
//    6 * Ê±    ¼ä£º2012Äê5ÔÂ19ÈÕ
//    7 *******************************************************************************/
//    8 
//    9 #include "adc.h"
//   10 
//   11 
//   12 /*******************************************************************************
//   13 * º¯ÊýÃû³Æ£ºADC_ClockCtrl
//   14 * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
//   15                     ADC0_BASE_PTR
//   16                     ADC1_BASE_PTR
//   17 * Ãè    Êö£ºÉèÖÃADÊ±ÖÓÔ´
//   18 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   19 void ADC_ClockCtrl(ADC_MemMapPtr adc)
//   20 {
//   21   if(adc == ADC0_BASE_PTR)
ADC_ClockCtrl:
        LDR.N    R1,??DataTable1  ;; 0x4003b000
        CMP      R0,R1
        BNE.N    ??ADC_ClockCtrl_0
//   22   {
//   23     SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;              // ´ò¿ª ADC0 Ê±ÖÓ 
        LDR.N    R0,??DataTable1_1  ;; 0x4004803c
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x8000000
        LDR.N    R1,??DataTable1_1  ;; 0x4004803c
        STR      R0,[R1, #+0]
        B.N      ??ADC_ClockCtrl_1
//   24   }
//   25   else if(adc == ADC1_BASE_PTR)
??ADC_ClockCtrl_0:
        LDR.N    R1,??DataTable1_2  ;; 0x400bb000
        CMP      R0,R1
        BNE.N    ??ADC_ClockCtrl_1
//   26   {
//   27     SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;              // ´ò¿ª ADC1 Ê±ÖÓ
        LDR.N    R0,??DataTable1_3  ;; 0x40048030
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x8000000
        LDR.N    R1,??DataTable1_3  ;; 0x40048030
        STR      R0,[R1, #+0]
//   28   }  
//   29 }
??ADC_ClockCtrl_1:
        BX       LR               ;; return
//   30 
//   31 /*******************************************************************************
//   32 * º¯ÊýÃû³Æ£ºADC_SetCFG1
//   33 * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
//   34                     ADC0_BASE_PTR
//   35                     ADC1_BASE_PTR
//   36             adiv   ·ÖÆµÏµÊý
//   37                     00 The divide ratio is 1 and the clock rate is input clock.
//   38                     01 The divide ratio is 2 and the clock rate is (input clock)/2.
//   39                     10 The divide ratio is 4 and the clock rate is (input clock)/4.
//   40                     11 The divide ratio is 8 and the clock rate is (input clock)/8.
//   41             bits   AD²ÉÑù¾«¶È
//   42                     00 When DIFF=0: It is single-ended  8-bit conversion; when DIFF=1, it is differential 9-bit conversionwith 2's complement output.
//   43                     01 When DIFF=0: It is single-ended 12-bit conversion; when DIFF=1, it is differential 13-bit conversionwith 2's complement output.
//   44                     10 When DIFF=0: It is single-ended 10-bit conversion; when DIFF=1, it is differential 11-bit conversionwith 2's complement output.
//   45                     11 When DIFF=0: It is single-ended 16-bit conversion; when DIFF=1, it is differential 16-bit conversionwith 2's complement output
//   46             adiclk ADÊ±ÖÓÔ´Ñ¡Ôñ
//   47                     00 Bus clock.
//   48                     01 Bus clock divided by 2.
//   49                     10 Alternate clock (ALTCLK).
//   50                     11 Asynchronous clock (ADACK)
//   51 * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG1
//   52 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   53 void ADC_SetCFG1(ADC_MemMapPtr adc, int8u_t adiv, int8u_t bits, int8u_t adiclk)
//   54 {   
ADC_SetCFG1:
        PUSH     {R4}
//   55   ADC_CFG1_REG(adc) |= ADC_CFG1_ADIV(adiv)            // ÅäÖÃ·ÖÆµÏµÊý
//   56                        + ADC_CFG1_ADLSMP_MASK         // ³¤²ÉÑùÊ±¼äÄ£Ê½
//   57                        + ADC_CFG1_MODE(bits)          // ²ÉÑù¾«¶È
//   58                        + ADC_CFG1_ADICLK(adiclk);     // ADCÊ±ÖÓÔ´Ñ¡Ôñ
        LDR      R4,[R0, #+8]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        LSLS     R1,R1,#+5
        ANDS     R1,R1,#0x60
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        LSLS     R2,R2,#+2
        ANDS     R2,R2,#0xC
        ADDS     R1,R2,R1
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ANDS     R2,R3,#0x3
        ADDS     R1,R2,R1
        ADDS     R1,R1,#+16
        ORRS     R1,R1,R4
        STR      R1,[R0, #+8]
//   59 }
        POP      {R4}
        BX       LR               ;; return
//   60 
//   61 /*******************************************************************************
//   62 * º¯ÊýÃû³Æ£ºADC_SetCFG2
//   63 * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
//   64                     ADC0_BASE_PTR
//   65                     ADC1_BASE_PTR
//   66             muxsel ADC Mux select
//   67                     0:ADxxa channels are selected.
//   68                     1:ADxxb channels are selected.
//   69             adhsc  High speed configuration
//   70                     0:Normal conversion sequence selected.
//   71                     1:High speed conversion sequence selected (2 additional ADCK cycles to total conversion time).
//   72             adlsts AD²ÉÑùÊ±¼äÑ¡Ôñ
//   73                     00 Default longest sample time (20 extra ADCK cycles; 24 ADCK cycles total).
//   74                     01 12 extra ADCK cycles; 16 ADCK cycles total sample time.
//   75                     10 6 extra ADCK cycles; 10 ADCK cycles total sample time.
//   76                     11 2 extra ADCK cycles; 6 ADCK cycles total sample time.
//   77 * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG2
//   78 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   79 void ADC_SetCFG2(ADC_MemMapPtr adc, int8u_t muxsel, int8u_t adhsc, int8u_t adlsts)
//   80 {
//   81   if(muxsel == 1)
ADC_SetCFG2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+1
        BNE.N    ??ADC_SetCFG2_0
//   82   {
//   83     ADC_CFG2_REG(adc) |= ADC_CFG2_MUXSEL_MASK;     // Ñ¡Ôñ ADCxxb
        LDR      R1,[R0, #+12]
        ORRS     R1,R1,#0x10
        STR      R1,[R0, #+12]
        B.N      ??ADC_SetCFG2_1
//   84   }
//   85   else
//   86   {
//   87     ADC_CFG2_REG(adc) &= ~ADC_CFG2_MUXSEL_MASK;    // Ñ¡Ôñ ADCxxa
??ADC_SetCFG2_0:
        LDR      R1,[R0, #+12]
        BICS     R1,R1,#0x10
        STR      R1,[R0, #+12]
//   88   }
//   89   ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADACKEN_MASK;     // Asynchronous clock output disabled
??ADC_SetCFG2_1:
        LDR      R1,[R0, #+12]
        BICS     R1,R1,#0x8
        STR      R1,[R0, #+12]
//   90   if(adhsc == 1)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??ADC_SetCFG2_2
//   91   {
//   92     ADC_CFG2_REG(adc) |= ADC_CFG2_ADHSC_MASK;      // ¸ßËÙ×ª»»¶ÓÁÐÑ¡Ôñ
        LDR      R1,[R0, #+12]
        ORRS     R1,R1,#0x4
        STR      R1,[R0, #+12]
        B.N      ??ADC_SetCFG2_3
//   93   }
//   94   else
//   95   {
//   96     ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADHSC_MASK;     // Õý³£×ª»»¶ÓÁÐÑ¡Ôñ
??ADC_SetCFG2_2:
        LDR      R1,[R0, #+12]
        BICS     R1,R1,#0x4
        STR      R1,[R0, #+12]
//   97   }
//   98   ADC_CFG2_REG(adc) |= ADC_CFG2_ADLSTS(adlsts);    // AD²ÉÑùÊ±¼äÑ¡Ôñ
??ADC_SetCFG2_3:
        LDR      R1,[R0, #+12]
        UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
        ANDS     R2,R3,#0x3
        ORRS     R1,R2,R1
        STR      R1,[R0, #+12]
//   99 }
        BX       LR               ;; return
//  100 
//  101 /*******************************************************************************
//  102 * º¯ÊýÃû³Æ£ºADC_SetSC
//  103 * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
//  104                      ADC0_BASE_PTR
//  105                      ADC1_BASE_PTR
//  106             avgs    Ó²¼þÂË²¨²ÉÑù´ÎÊýÑ¡Ôñ
//  107                      00 4 samples averaged.
//  108                      01 8 samples averaged.
//  109                      10 16 samples averaged.
//  110                      11 32 samples averaged.
//  111             aien    AD²ÉÑù½á¹û¶ÁÈ¡·½Ê½
//  112                      0:²éÑ¯·½Ê½
//  113                      1:ÖÐ¶Ï·½Ê½
//  114             prio    ÖÐ¶ÏÓÅÏÈ¼¶£¬Ö»ÔÚ aien=1 ÊÇÓÐÐ§
//  115 * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_SCn
//  116 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  117 void ADC_SetSC(ADC_MemMapPtr adc, int8u_t avgs, int8u_t aien, int8u_t prio)
//  118 {
ADC_SetSC:
        PUSH     {R4,LR}
        MOVS     R4,R3
//  119   ADC_SC2_REG(adc) = 0;   // set default status:Software triger(a convertion is initated following a write to 
        MOVS     R3,#+0
        STR      R3,[R0, #+32]
//  120                           // SC1A)compare function disabled, DMA is disabled, default voltage reference pin(external pins VREFH and VREFL).
//  121   ADC_SC3_REG(adc) |= ADC_SC3_ADCO_MASK            // Á¬Ðø×ª»»Ä£Ê½
//  122                       + ADC_SC3_AVGE_MASK          // Ó²¼þÂË²¨Ê¹ÄÜ
//  123                       + ADC_SC3_AVGS(avgs);        // ÉèÖÃÁ¬Ðø²ÉÑù´ÎÊý             
        LDR      R3,[R0, #+36]
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ANDS     R1,R1,#0x3
        ADDS     R1,R1,#+12
        ORRS     R1,R1,R3
        STR      R1,[R0, #+36]
//  124   if(aien == 1)
        UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
        CMP      R2,#+1
        BNE.N    ??ADC_SetSC_0
//  125   {
//  126     ADC_SC1_REG(adc,0)  |= ADC_SC1_AIEN_MASK;      // ÖÃÎ»ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷
        LDR      R1,[R0, #+0]
        ORRS     R1,R1,#0x40
        STR      R1,[R0, #+0]
//  127     if(adc == ADC0_BASE_PTR)
        LDR.N    R1,??DataTable1  ;; 0x4003b000
        CMP      R0,R1
        BNE.N    ??ADC_SetSC_1
//  128     {
//  129       EnableInt_Kinetis(57);
        MOVS     R0,#+57
        BL       EnableInt_Kinetis
//  130       SetIntPri_Kinetis(57,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,R4
        MOVS     R0,#+57
        BL       SetIntPri_Kinetis
        B.N      ??ADC_SetSC_2
//  131     }
//  132     else if(adc == ADC1_BASE_PTR)
??ADC_SetSC_1:
        LDR.N    R1,??DataTable1_2  ;; 0x400bb000
        CMP      R0,R1
        BNE.N    ??ADC_SetSC_2
//  133     {
//  134       EnableInt_Kinetis(58);
        MOVS     R0,#+58
        BL       EnableInt_Kinetis
//  135       SetIntPri_Kinetis(58,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        MOVS     R1,R4
        MOVS     R0,#+58
        BL       SetIntPri_Kinetis
        B.N      ??ADC_SetSC_2
//  136     }
//  137   }
//  138   else
//  139   {
//  140     ADC_SC1_REG(adc,0)  &= ~ADC_SC1_AIEN_MASK;     // ²éÑ¯·½Ê½
??ADC_SetSC_0:
        LDR      R1,[R0, #+0]
        BICS     R1,R1,#0x40
        STR      R1,[R0, #+0]
//  141   }
//  142 }
??ADC_SetSC_2:
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1:
        DC32     0x4003b000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_1:
        DC32     0x4004803c

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_2:
        DC32     0x400bb000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable1_3:
        DC32     0x40048030
//  143 
//  144 /*******************************************************************************
//  145 * º¯ÊýÃû³Æ£ºADC_readResult
//  146 * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
//  147                      ADC0_BASE_PTR
//  148                      ADC1_BASE_PTR
//  149             channel AD²ÉÑùÍ¨µÀºÅ
//  150                      00000 When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
//  151                      00001 When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
//  152                      00010 When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
//  153                      00011 When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
//  154                      00100 When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
//  155                      00101 When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
//  156                      00110 When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
//  157                      00111 When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
//  158                      01000 When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
//  159                      01001 When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
//  160                      01010 When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
//  161                      01011 When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
//  162                      01100 When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
//  163                      01101 When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
//  164                      01110 When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
//  165                      01111 When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
//  166                      10000 When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
//  167                      10001 When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
//  168                      10010 When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
//  169                      10011 When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
//  170                      10100 When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
//  171                      10101 When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
//  172                      10110 When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
//  173                      10111 When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
//  174                      11000 Reserved.
//  175                      11001 Reserved.
//  176                      11010 When DIFF=0, Temp sensor (single-ended) is selected as input; when DIFF=1, Temp sensor(differential) is selected as input.
//  177                      11011 When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap(differential) is selected as input.
//  178                      11100 Reserved.
//  179                      11101 When DIFF=0, VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected asinput. 
//  180                      11110 When DIFF=0, VREFSL is selected as input; when DIFF=1, it is reserved. Voltage referenceselected is determined by the REFSEL bits in the SC2 register.
//  181                      11111 Module disabled.
//  182             result  AD²ÉÑù½á¹û
//  183 * Ãè    Êö£º¶ÁÈ¡AD×ª»»½á¹û£¬Í¨¹ýÅäÖÃADÍ¨µÀ¿É¿ªÊ¼AD²ÉÑù
//  184 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  185 void ADC_readResult(ADC_MemMapPtr adc,int8u_t channel, int16u_t * result)
//  186 {
ADC_readResult:
        PUSH     {R4}
//  187   int32u_t readReg = 0;
        MOVS     R3,#+0
//  188   
//  189   readReg = ADC_SC1_REG(adc,0);
        LDR      R4,[R0, #+0]
        MOVS     R3,R4
//  190   readReg &= ~ADC_SC1_ADCH_MASK;
        LSRS     R3,R3,#+5
        LSLS     R3,R3,#+5
//  191   readReg |= ADC_SC1_ADCH(channel);
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ANDS     R1,R1,#0x1F
        ORRS     R3,R1,R3
//  192   ADC_SC1_REG(adc,0) = readReg;                      // ÉèÖÃ ADC ²ÉÑùÍ¨µÀ
        STR      R3,[R0, #+0]
//  193   
//  194   while(!(ADC_SC1_REG(adc,0)&ADC_SC1_COCO_MASK));    // µÈ´ý ADC ×ª»»½áÊø
??ADC_readResult_0:
        LDR      R1,[R0, #+0]
        LSLS     R1,R1,#+24
        BPL.N    ??ADC_readResult_0
//  195   *result = ADC_R_REG(adc,0);                        // ¶ÁÈ¡ ADC ½á¹û¼Ä´æÆ÷£¬COCO ×Ô¶¯ÇåÁã
        LDR      R0,[R0, #+16]
        STRH     R0,[R2, #+0]
//  196 }
        POP      {R4}
        BX       LR               ;; return

        SECTION `.iar_vfe_header`:DATA:REORDER:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 
// 296 bytes in section .text
// 
// 296 bytes of CODE memory
//
//Errors: none
//Warnings: none
