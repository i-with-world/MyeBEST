###############################################################################
#                                                                             #
#                                                       10/Jan/2013  19:05:36 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\D #
#                    rivers\ADC\adc.c                                         #
#    Command line =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\D #
#                    rivers\ADC\adc.c -D IAR -lCN                             #
#                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\Lis #
#                    t\ -lB E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ #
#                    °Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\De #
#                    bug\List\ -o E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì× #
#                    ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0. #
#                    0.3\Debug\Obj\ --no_cse --no_unroll --no_inline          #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M4  #
#                    -e --fpu=None --dlib_config                              #
#                    D:\Tools\IAR6.30\arm\INC\c\DLib_Config_Normal.h -I       #
#                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\C #
#                    PU\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ #
#                    °Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Li #
#                    brary\Drivers\ADC\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁ #
#                    Ï\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\201 #
#                    30110\V0.0.3\Library\Drivers\FTM\ -I                     #
#                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\D #
#                    rivers\GPIO\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë #
#                    ½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\ #
#                    V0.0.3\Library\Drivers\PIT\ -Ol                          #
#    List file    =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\Lis #
#                    t\adc.lst                                                #
#    Object file  =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄ #
#                    Ü³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\Obj #
#                    \adc.o                                                   #
#                                                                             #
#                                                                             #
###############################################################################

E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\Drivers\ADC\adc.c
      1          /*******************************************************************************
      2          * ÎÄ¼þÃû³Æ£ºadc.c
      3          * Ãè    Êö: ADCÇý¶¯³ÌÐò,²¢Ã»ÓÐ½«¶ÔÓ¦µÄÒý½ÅÉèÎªAD¹¦ÄÜ£¨²Î¿¼¼Í³ÉÊ¦ÐÖÇý¶¯³ÌÐò£©
      4          * ×÷    Õß£ºÍò±ù±ù
      5          * ÌØ±ðÃùÐ»£º¼Í³ÉÊ¦ÐÖ(²©¿Íhttp://blog.chinaaet.com/jihceng0622)
      6          * Ê±    ¼ä£º2012Äê5ÔÂ19ÈÕ
      7          *******************************************************************************/
      8          
      9          #include "adc.h"
     10          
     11          
     12          /*******************************************************************************
     13          * º¯ÊýÃû³Æ£ºADC_ClockCtrl
     14          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     15                              ADC0_BASE_PTR
     16                              ADC1_BASE_PTR
     17          * Ãè    Êö£ºÉèÖÃADÊ±ÖÓÔ´
     18          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     19          void ADC_ClockCtrl(ADC_MemMapPtr adc)
     20          {
     21            if(adc == ADC0_BASE_PTR)
   \                     ADC_ClockCtrl:
   \   00000000   0x....             LDR.N    R1,??DataTable1  ;; 0x4003b000
   \   00000002   0x4288             CMP      R0,R1
   \   00000004   0xD106             BNE.N    ??ADC_ClockCtrl_0
     22            {
     23              SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;              // ´ò¿ª ADC0 Ê±ÖÓ 
   \   00000006   0x....             LDR.N    R0,??DataTable1_1  ;; 0x4004803c
   \   00000008   0x6800             LDR      R0,[R0, #+0]
   \   0000000A   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   0000000E   0x....             LDR.N    R1,??DataTable1_1  ;; 0x4004803c
   \   00000010   0x6008             STR      R0,[R1, #+0]
   \   00000012   0xE008             B.N      ??ADC_ClockCtrl_1
     24            }
     25            else if(adc == ADC1_BASE_PTR)
   \                     ??ADC_ClockCtrl_0:
   \   00000014   0x....             LDR.N    R1,??DataTable1_2  ;; 0x400bb000
   \   00000016   0x4288             CMP      R0,R1
   \   00000018   0xD105             BNE.N    ??ADC_ClockCtrl_1
     26            {
     27              SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;              // ´ò¿ª ADC1 Ê±ÖÓ
   \   0000001A   0x....             LDR.N    R0,??DataTable1_3  ;; 0x40048030
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0xF050 0x6000      ORRS     R0,R0,#0x8000000
   \   00000022   0x....             LDR.N    R1,??DataTable1_3  ;; 0x40048030
   \   00000024   0x6008             STR      R0,[R1, #+0]
     28            }  
     29          }
   \                     ??ADC_ClockCtrl_1:
   \   00000026   0x4770             BX       LR               ;; return
     30          
     31          /*******************************************************************************
     32          * º¯ÊýÃû³Æ£ºADC_SetCFG1
     33          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     34                              ADC0_BASE_PTR
     35                              ADC1_BASE_PTR
     36                      adiv   ·ÖÆµÏµÊý
     37                              00 The divide ratio is 1 and the clock rate is input clock.
     38                              01 The divide ratio is 2 and the clock rate is (input clock)/2.
     39                              10 The divide ratio is 4 and the clock rate is (input clock)/4.
     40                              11 The divide ratio is 8 and the clock rate is (input clock)/8.
     41                      bits   AD²ÉÑù¾«¶È
     42                              00 When DIFF=0: It is single-ended  8-bit conversion; when DIFF=1, it is differential 9-bit conversionwith 2's complement output.
     43                              01 When DIFF=0: It is single-ended 12-bit conversion; when DIFF=1, it is differential 13-bit conversionwith 2's complement output.
     44                              10 When DIFF=0: It is single-ended 10-bit conversion; when DIFF=1, it is differential 11-bit conversionwith 2's complement output.
     45                              11 When DIFF=0: It is single-ended 16-bit conversion; when DIFF=1, it is differential 16-bit conversionwith 2's complement output
     46                      adiclk ADÊ±ÖÓÔ´Ñ¡Ôñ
     47                              00 Bus clock.
     48                              01 Bus clock divided by 2.
     49                              10 Alternate clock (ALTCLK).
     50                              11 Asynchronous clock (ADACK)
     51          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG1
     52          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          void ADC_SetCFG1(ADC_MemMapPtr adc, int8u_t adiv, int8u_t bits, int8u_t adiclk)
     54          {   
   \                     ADC_SetCFG1:
   \   00000000   0xB410             PUSH     {R4}
     55            ADC_CFG1_REG(adc) |= ADC_CFG1_ADIV(adiv)            // ÅäÖÃ·ÖÆµÏµÊý
     56                                 + ADC_CFG1_ADLSMP_MASK         // ³¤²ÉÑùÊ±¼äÄ£Ê½
     57                                 + ADC_CFG1_MODE(bits)          // ²ÉÑù¾«¶È
     58                                 + ADC_CFG1_ADICLK(adiclk);     // ADCÊ±ÖÓÔ´Ñ¡Ôñ
   \   00000002   0x6884             LDR      R4,[R0, #+8]
   \   00000004   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000006   0x0149             LSLS     R1,R1,#+5
   \   00000008   0xF011 0x0160      ANDS     R1,R1,#0x60
   \   0000000C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000000E   0x0092             LSLS     R2,R2,#+2
   \   00000010   0xF012 0x020C      ANDS     R2,R2,#0xC
   \   00000014   0x1851             ADDS     R1,R2,R1
   \   00000016   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   00000018   0xF013 0x0203      ANDS     R2,R3,#0x3
   \   0000001C   0x1851             ADDS     R1,R2,R1
   \   0000001E   0x3110             ADDS     R1,R1,#+16
   \   00000020   0x4321             ORRS     R1,R1,R4
   \   00000022   0x6081             STR      R1,[R0, #+8]
     59          }
   \   00000024   0xBC10             POP      {R4}
   \   00000026   0x4770             BX       LR               ;; return
     60          
     61          /*******************************************************************************
     62          * º¯ÊýÃû³Æ£ºADC_SetCFG2
     63          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     64                              ADC0_BASE_PTR
     65                              ADC1_BASE_PTR
     66                      muxsel ADC Mux select
     67                              0:ADxxa channels are selected.
     68                              1:ADxxb channels are selected.
     69                      adhsc  High speed configuration
     70                              0:Normal conversion sequence selected.
     71                              1:High speed conversion sequence selected (2 additional ADCK cycles to total conversion time).
     72                      adlsts AD²ÉÑùÊ±¼äÑ¡Ôñ
     73                              00 Default longest sample time (20 extra ADCK cycles; 24 ADCK cycles total).
     74                              01 12 extra ADCK cycles; 16 ADCK cycles total sample time.
     75                              10 6 extra ADCK cycles; 10 ADCK cycles total sample time.
     76                              11 2 extra ADCK cycles; 6 ADCK cycles total sample time.
     77          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG2
     78          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     79          void ADC_SetCFG2(ADC_MemMapPtr adc, int8u_t muxsel, int8u_t adhsc, int8u_t adlsts)
     80          {
     81            if(muxsel == 1)
   \                     ADC_SetCFG2:
   \   00000000   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   00000002   0x2901             CMP      R1,#+1
   \   00000004   0xD104             BNE.N    ??ADC_SetCFG2_0
     82            {
     83              ADC_CFG2_REG(adc) |= ADC_CFG2_MUXSEL_MASK;     // Ñ¡Ôñ ADCxxb
   \   00000006   0x68C1             LDR      R1,[R0, #+12]
   \   00000008   0xF051 0x0110      ORRS     R1,R1,#0x10
   \   0000000C   0x60C1             STR      R1,[R0, #+12]
   \   0000000E   0xE003             B.N      ??ADC_SetCFG2_1
     84            }
     85            else
     86            {
     87              ADC_CFG2_REG(adc) &= ~ADC_CFG2_MUXSEL_MASK;    // Ñ¡Ôñ ADCxxa
   \                     ??ADC_SetCFG2_0:
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
   \   00000012   0xF031 0x0110      BICS     R1,R1,#0x10
   \   00000016   0x60C1             STR      R1,[R0, #+12]
     88            }
     89            ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADACKEN_MASK;     // Asynchronous clock output disabled
   \                     ??ADC_SetCFG2_1:
   \   00000018   0x68C1             LDR      R1,[R0, #+12]
   \   0000001A   0xF031 0x0108      BICS     R1,R1,#0x8
   \   0000001E   0x60C1             STR      R1,[R0, #+12]
     90            if(adhsc == 1)
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x2A01             CMP      R2,#+1
   \   00000024   0xD104             BNE.N    ??ADC_SetCFG2_2
     91            {
     92              ADC_CFG2_REG(adc) |= ADC_CFG2_ADHSC_MASK;      // ¸ßËÙ×ª»»¶ÓÁÐÑ¡Ôñ
   \   00000026   0x68C1             LDR      R1,[R0, #+12]
   \   00000028   0xF051 0x0104      ORRS     R1,R1,#0x4
   \   0000002C   0x60C1             STR      R1,[R0, #+12]
   \   0000002E   0xE003             B.N      ??ADC_SetCFG2_3
     93            }
     94            else
     95            {
     96              ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADHSC_MASK;     // Õý³£×ª»»¶ÓÁÐÑ¡Ôñ
   \                     ??ADC_SetCFG2_2:
   \   00000030   0x68C1             LDR      R1,[R0, #+12]
   \   00000032   0xF031 0x0104      BICS     R1,R1,#0x4
   \   00000036   0x60C1             STR      R1,[R0, #+12]
     97            }
     98            ADC_CFG2_REG(adc) |= ADC_CFG2_ADLSTS(adlsts);    // AD²ÉÑùÊ±¼äÑ¡Ôñ
   \                     ??ADC_SetCFG2_3:
   \   00000038   0x68C1             LDR      R1,[R0, #+12]
   \   0000003A   0xB2DB             UXTB     R3,R3            ;; ZeroExt  R3,R3,#+24,#+24
   \   0000003C   0xF013 0x0203      ANDS     R2,R3,#0x3
   \   00000040   0x4311             ORRS     R1,R2,R1
   \   00000042   0x60C1             STR      R1,[R0, #+12]
     99          }
   \   00000044   0x4770             BX       LR               ;; return
    100          
    101          /*******************************************************************************
    102          * º¯ÊýÃû³Æ£ºADC_SetSC
    103          * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
    104                               ADC0_BASE_PTR
    105                               ADC1_BASE_PTR
    106                      avgs    Ó²¼þÂË²¨²ÉÑù´ÎÊýÑ¡Ôñ
    107                               00 4 samples averaged.
    108                               01 8 samples averaged.
    109                               10 16 samples averaged.
    110                               11 32 samples averaged.
    111                      aien    AD²ÉÑù½á¹û¶ÁÈ¡·½Ê½
    112                               0:²éÑ¯·½Ê½
    113                               1:ÖÐ¶Ï·½Ê½
    114                      prio    ÖÐ¶ÏÓÅÏÈ¼¶£¬Ö»ÔÚ aien=1 ÊÇÓÐÐ§
    115          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_SCn
    116          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          void ADC_SetSC(ADC_MemMapPtr adc, int8u_t avgs, int8u_t aien, int8u_t prio)
    118          {
   \                     ADC_SetSC:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x001C             MOVS     R4,R3
    119            ADC_SC2_REG(adc) = 0;   // set default status:Software triger(a convertion is initated following a write to 
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x6203             STR      R3,[R0, #+32]
    120                                    // SC1A)compare function disabled, DMA is disabled, default voltage reference pin(external pins VREFH and VREFL).
    121            ADC_SC3_REG(adc) |= ADC_SC3_ADCO_MASK            // Á¬Ðø×ª»»Ä£Ê½
    122                                + ADC_SC3_AVGE_MASK          // Ó²¼þÂË²¨Ê¹ÄÜ
    123                                + ADC_SC3_AVGS(avgs);        // ÉèÖÃÁ¬Ðø²ÉÑù´ÎÊý             
   \   00000008   0x6A43             LDR      R3,[R0, #+36]
   \   0000000A   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000C   0xF011 0x0103      ANDS     R1,R1,#0x3
   \   00000010   0x310C             ADDS     R1,R1,#+12
   \   00000012   0x4319             ORRS     R1,R1,R3
   \   00000014   0x6241             STR      R1,[R0, #+36]
    124            if(aien == 1)
   \   00000016   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000018   0x2A01             CMP      R2,#+1
   \   0000001A   0xD11B             BNE.N    ??ADC_SetSC_0
    125            {
    126              ADC_SC1_REG(adc,0)  |= ADC_SC1_AIEN_MASK;      // ÖÃÎ»ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷
   \   0000001C   0x6801             LDR      R1,[R0, #+0]
   \   0000001E   0xF051 0x0140      ORRS     R1,R1,#0x40
   \   00000022   0x6001             STR      R1,[R0, #+0]
    127              if(adc == ADC0_BASE_PTR)
   \   00000024   0x....             LDR.N    R1,??DataTable1  ;; 0x4003b000
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD108             BNE.N    ??ADC_SetSC_1
    128              {
    129                EnableInt_Kinetis(57);
   \   0000002A   0x2039             MOVS     R0,#+57
   \   0000002C   0x.... 0x....      BL       EnableInt_Kinetis
    130                SetIntPri_Kinetis(57,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
   \   00000030   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000032   0x0021             MOVS     R1,R4
   \   00000034   0x2039             MOVS     R0,#+57
   \   00000036   0x.... 0x....      BL       SetIntPri_Kinetis
   \   0000003A   0xE00F             B.N      ??ADC_SetSC_2
    131              }
    132              else if(adc == ADC1_BASE_PTR)
   \                     ??ADC_SetSC_1:
   \   0000003C   0x....             LDR.N    R1,??DataTable1_2  ;; 0x400bb000
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xD10C             BNE.N    ??ADC_SetSC_2
    133              {
    134                EnableInt_Kinetis(58);
   \   00000042   0x203A             MOVS     R0,#+58
   \   00000044   0x.... 0x....      BL       EnableInt_Kinetis
    135                SetIntPri_Kinetis(58,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
   \   00000048   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004A   0x0021             MOVS     R1,R4
   \   0000004C   0x203A             MOVS     R0,#+58
   \   0000004E   0x.... 0x....      BL       SetIntPri_Kinetis
   \   00000052   0xE003             B.N      ??ADC_SetSC_2
    136              }
    137            }
    138            else
    139            {
    140              ADC_SC1_REG(adc,0)  &= ~ADC_SC1_AIEN_MASK;     // ²éÑ¯·½Ê½
   \                     ??ADC_SetSC_0:
   \   00000054   0x6801             LDR      R1,[R0, #+0]
   \   00000056   0xF031 0x0140      BICS     R1,R1,#0x40
   \   0000005A   0x6001             STR      R1,[R0, #+0]
    141            }
    142          }
   \                     ??ADC_SetSC_2:
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
    143          
    144          /*******************************************************************************
    145          * º¯ÊýÃû³Æ£ºADC_readResult
    146          * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
    147                               ADC0_BASE_PTR
    148                               ADC1_BASE_PTR
    149                      channel AD²ÉÑùÍ¨µÀºÅ
    150                               00000 When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
    151                               00001 When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
    152                               00010 When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
    153                               00011 When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
    154                               00100 When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
    155                               00101 When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
    156                               00110 When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
    157                               00111 When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
    158                               01000 When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
    159                               01001 When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
    160                               01010 When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
    161                               01011 When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
    162                               01100 When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
    163                               01101 When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
    164                               01110 When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
    165                               01111 When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
    166                               10000 When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
    167                               10001 When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
    168                               10010 When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
    169                               10011 When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
    170                               10100 When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
    171                               10101 When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
    172                               10110 When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
    173                               10111 When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
    174                               11000 Reserved.
    175                               11001 Reserved.
    176                               11010 When DIFF=0, Temp sensor (single-ended) is selected as input; when DIFF=1, Temp sensor(differential) is selected as input.
    177                               11011 When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap(differential) is selected as input.
    178                               11100 Reserved.
    179                               11101 When DIFF=0, VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected asinput. 
    180                               11110 When DIFF=0, VREFSL is selected as input; when DIFF=1, it is reserved. Voltage referenceselected is determined by the REFSEL bits in the SC2 register.
    181                               11111 Module disabled.
    182                      result  AD²ÉÑù½á¹û
    183          * Ãè    Êö£º¶ÁÈ¡AD×ª»»½á¹û£¬Í¨¹ýÅäÖÃADÍ¨µÀ¿É¿ªÊ¼AD²ÉÑù
    184          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    185          void ADC_readResult(ADC_MemMapPtr adc,int8u_t channel, int16u_t * result)
    186          {
   \                     ADC_readResult:
   \   00000000   0xB410             PUSH     {R4}
    187            int32u_t readReg = 0;
   \   00000002   0x2300             MOVS     R3,#+0
    188            
    189            readReg = ADC_SC1_REG(adc,0);
   \   00000004   0x6804             LDR      R4,[R0, #+0]
   \   00000006   0x0023             MOVS     R3,R4
    190            readReg &= ~ADC_SC1_ADCH_MASK;
   \   00000008   0x095B             LSRS     R3,R3,#+5
   \   0000000A   0x015B             LSLS     R3,R3,#+5
    191            readReg |= ADC_SC1_ADCH(channel);
   \   0000000C   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   0000000E   0xF011 0x011F      ANDS     R1,R1,#0x1F
   \   00000012   0x430B             ORRS     R3,R1,R3
    192            ADC_SC1_REG(adc,0) = readReg;                      // ÉèÖÃ ADC ²ÉÑùÍ¨µÀ
   \   00000014   0x6003             STR      R3,[R0, #+0]
    193            
    194            while(!(ADC_SC1_REG(adc,0)&ADC_SC1_COCO_MASK));    // µÈ´ý ADC ×ª»»½áÊø
   \                     ??ADC_readResult_0:
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x0609             LSLS     R1,R1,#+24
   \   0000001A   0xD5FC             BPL.N    ??ADC_readResult_0
    195            *result = ADC_R_REG(adc,0);                        // ¶ÁÈ¡ ADC ½á¹û¼Ä´æÆ÷£¬COCO ×Ô¶¯ÇåÁã
   \   0000001C   0x6900             LDR      R0,[R0, #+16]
   \   0000001E   0x8010             STRH     R0,[R2, #+0]
    196          }
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x4004803C         DC32     0x4004803c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x400BB000         DC32     0x400bb000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x40048030         DC32     0x40048030

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_ClockCtrl
        4  ADC_SetCFG1
        0  ADC_SetCFG2
        8  ADC_SetSC
             8 -> EnableInt_Kinetis
             8 -> SetIntPri_Kinetis
        4  ADC_readResult


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
      40  ADC_ClockCtrl
      40  ADC_SetCFG1
      70  ADC_SetCFG2
      94  ADC_SetSC
      36  ADC_readResult

 
 296 bytes in section .text
 
 296 bytes of CODE memory

Errors: none
Warnings: none
