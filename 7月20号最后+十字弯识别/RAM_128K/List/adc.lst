###############################################################################
#                                                                             #
#                                                       30/Oct/2014  20:23:22 #
# IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM                #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Library\Dr #
#                    ivers\ADC\adc.c                                          #
#    Command line =  E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Library\Dr #
#                    ivers\ADC\adc.c -D IAR -lCN                              #
#                    E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\RAM_128K\L #
#                    ist\ -lB E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\R #
#                    AM_128K\List\ -o E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029 #
#                    µ÷ÊÔ°æ\RAM_128K\Obj\ --debug --endian=little             #
#                    --cpu=Cortex-M4 -e --fpu=None --dlib_config "C:\Program  #
#                    Files\IAR Systems\Embedded Workbench 6.0                 #
#                    Evaluation\arm\INC\c\DLib_Config_Normal.h" -I            #
#                    E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Library\CP #
#                    U\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Libr #
#                    ary\Drivers\ADC\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1 #
#                    029µ÷ÊÔ°æ\Library\Drivers\FTM\ -I                        #
#                    E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Library\Dr #
#                    ivers\GPIO\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ #
#                    ÊÔ°æ\Library\Drivers\PIT\ -I                             #
#                    E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\System_Ini #
#                    t\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Sour #
#                    ce\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\OLE #
#                    D\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\SD_S #
#                    ystem\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\ #
#                    Simple_AD\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷Ê #
#                    Ô°æ\Delay\ -I E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷Ê #
#                    Ô°æ\Make_Desicion\ -Oh                                   #
#    List file    =  E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\RAM_128K\L #
#                    ist\adc.lst                                              #
#    Object file  =  E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\RAM_128K\O #
#                    bj\adc.o                                                 #
#                                                                             #
#                                                                             #
###############################################################################

E:\´´ÐÂ»î¶¯\ÖÇÄÜ³µ\µÚÊ®½ì\±¾³µ³ÌÐò\1029µ÷ÊÔ°æ\Library\Drivers\ADC\adc.c
      1          /*******************************************************************************
      2          * ÎÄ¼þÃû³Æ£ºadc.c
      3          * Ãè    Êö: ADCÇý¶¯³ÌÐò,²¢Ã»ÓÐ½«¶ÔÓ¦µÄÒý½ÅÉèÎªAD¹¦ÄÜ£¨²Î¿¼¼Í³ÉÊ¦ÐÖÇý¶¯³ÌÐò£©
      4          * ×÷    Õß£ºÍò±ù±ù
      5          * ÌØ±ðÃùÐ»£º¼Í³ÉÊ¦ÐÖ(²©¿Íhttp://blog.chinaaet.com/jihceng0622)
      6          * Ê±    ¼ä£º2012Äê5ÔÂ19ÈÕ
      7          *******************************************************************************/
      8          
      9          #include "adc.h"
     10          
     11          
     12          /*******************************************************************************
     13          * º¯ÊýÃû³Æ£ºADC_ClockCtrl
     14          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     15                              ADC0_BASE_PTR
     16                              ADC1_BASE_PTR
     17          * Ãè    Êö£ºÉèÖÃADÊ±ÖÓÔ´
     18          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     19          void ADC_ClockCtrl(ADC_MemMapPtr adc)
     20          {
     21            if(adc == ADC0_BASE_PTR)
   \                     ADC_ClockCtrl:
   \   00000000   0x....             LDR.N    R1,??DataTable1  ;; 0x4003b000
   \   00000002   0x4288             CMP      R0,R1
   \   00000004   0xD105             BNE.N    ??ADC_ClockCtrl_0
     22            {
     23              SIM_SCGC6 |= SIM_SCGC6_ADC0_MASK;              // ´ò¿ª ADC0 Ê±ÖÓ 
   \   00000006   0x....             LDR.N    R0,??DataTable1_1  ;; 0x40048030
   \   00000008   0x68C1             LDR      R1,[R0, #+12]
   \   0000000A   0xF041 0x6100      ORR      R1,R1,#0x8000000
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
   \   00000010   0x4770             BX       LR
     24            }
     25            else if(adc == ADC1_BASE_PTR)
   \                     ??ADC_ClockCtrl_0:
   \   00000012   0x....             LDR.N    R1,??DataTable1_2  ;; 0x400bb000
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD104             BNE.N    ??ADC_ClockCtrl_1
     26            {
     27              SIM_SCGC3 |= SIM_SCGC3_ADC1_MASK;              // ´ò¿ª ADC1 Ê±ÖÓ
   \   00000018   0x....             LDR.N    R0,??DataTable1_1  ;; 0x40048030
   \   0000001A   0x6801             LDR      R1,[R0, #+0]
   \   0000001C   0xF041 0x6100      ORR      R1,R1,#0x8000000
   \   00000020   0x6001             STR      R1,[R0, #+0]
     28            }  
     29          }
   \                     ??ADC_ClockCtrl_1:
   \   00000022   0x4770             BX       LR               ;; return
     30          
     31          /*******************************************************************************
     32          * º¯ÊýÃû³Æ£ºADC_SetCFG1
     33          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     34                              ADC0_BASE_PTR
     35                              ADC1_BASE_PTR
     36                      adiv   ·ÖÆµÏµÊý
     37                              00 The divide ratio is 1 and the clock rate is input clock.
     38                              01 The divide ratio is 2 and the clock rate is (input clock)/2.
     39                              10 The divide ratio is 4 and the clock rate is (input clock)/4.
     40                              11 The divide ratio is 8 and the clock rate is (input clock)/8.
     41                      bits   AD²ÉÑù¾«¶È
     42                              00 When DIFF=0: It is single-ended  8-bit conversion; when DIFF=1, it is differential 9-bit conversionwith 2's complement output.
     43                              01 When DIFF=0: It is single-ended 12-bit conversion; when DIFF=1, it is differential 13-bit conversionwith 2's complement output.
     44                              10 When DIFF=0: It is single-ended 10-bit conversion; when DIFF=1, it is differential 11-bit conversionwith 2's complement output.
     45                              11 When DIFF=0: It is single-ended 16-bit conversion; when DIFF=1, it is differential 16-bit conversionwith 2's complement output
     46                      adiclk ADÊ±ÖÓÔ´Ñ¡Ôñ
     47                              00 Bus clock.
     48                              01 Bus clock divided by 2.
     49                              10 Alternate clock (ALTCLK).
     50                              11 Asynchronous clock (ADACK)
     51          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG1
     52          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     53          void ADC_SetCFG1(ADC_MemMapPtr adc, int8u_t adiv, int8u_t bits, int8u_t adiclk)
     54          {   
     55            ADC_CFG1_REG(adc) |= ADC_CFG1_ADIV(adiv)            // ÅäÖÃ·ÖÆµÏµÊý
     56                                 + ADC_CFG1_ADLSMP_MASK         // ³¤²ÉÑùÊ±¼äÄ£Ê½
     57                                 + ADC_CFG1_MODE(bits)          // ²ÉÑù¾«¶È
     58                                 + ADC_CFG1_ADICLK(adiclk);     // ADCÊ±ÖÓÔ´Ñ¡Ôñ
   \                     ADC_SetCFG1:
   \   00000000   0x0149             LSLS     R1,R1,#+5
   \   00000002   0x0092             LSLS     R2,R2,#+2
   \   00000004   0xF001 0x0160      AND      R1,R1,#0x60
   \   00000008   0xF002 0x020C      AND      R2,R2,#0xC
   \   0000000C   0x1851             ADDS     R1,R2,R1
   \   0000000E   0xF003 0x0203      AND      R2,R3,#0x3
   \   00000012   0xF8D0 0xC008      LDR      R12,[R0, #+8]
   \   00000016   0x1851             ADDS     R1,R2,R1
   \   00000018   0x3110             ADDS     R1,R1,#+16
   \   0000001A   0xEA41 0x010C      ORR      R1,R1,R12
   \   0000001E   0x6081             STR      R1,[R0, #+8]
     59          }
   \   00000020   0x4770             BX       LR               ;; return
     60          
     61          /*******************************************************************************
     62          * º¯ÊýÃû³Æ£ºADC_SetCFG2
     63          * Èë¿Ú²ÎÊý£ºadc    AD×ª»»Æ÷Ñ¡Ôñ
     64                              ADC0_BASE_PTR
     65                              ADC1_BASE_PTR
     66                      muxsel ADC Mux select
     67                              0:ADxxa channels are selected.
     68                              1:ADxxb channels are selected.
     69                      adhsc  High speed configuration
     70                              0:Normal conversion sequence selected.
     71                              1:High speed conversion sequence selected (2 additional ADCK cycles to total conversion time).
     72                      adlsts AD²ÉÑùÊ±¼äÑ¡Ôñ
     73                              00 Default longest sample time (20 extra ADCK cycles; 24 ADCK cycles total).
     74                              01 12 extra ADCK cycles; 16 ADCK cycles total sample time.
     75                              10 6 extra ADCK cycles; 10 ADCK cycles total sample time.
     76                              11 2 extra ADCK cycles; 6 ADCK cycles total sample time.
     77          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_CFG2
     78          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
     79          void ADC_SetCFG2(ADC_MemMapPtr adc, int8u_t muxsel, int8u_t adhsc, int8u_t adlsts)
     80          {
     81            if(muxsel == 1)
   \                     ADC_SetCFG2:
   \   00000000   0x2901             CMP      R1,#+1
   \   00000002   0x68C1             LDR      R1,[R0, #+12]
   \   00000004   0xBF0C             ITE      EQ 
   \   00000006   0xF041 0x0110      ORREQ    R1,R1,#0x10
   \   0000000A   0xF021 0x0110      BICNE    R1,R1,#0x10
     82            {
     83              ADC_CFG2_REG(adc) |= ADC_CFG2_MUXSEL_MASK;     // Ñ¡Ôñ ADCxxb
     84            }
     85            else
     86            {
     87              ADC_CFG2_REG(adc) &= ~ADC_CFG2_MUXSEL_MASK;    // Ñ¡Ôñ ADCxxa
   \   0000000E   0x60C1             STR      R1,[R0, #+12]
     88            }
     89            ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADACKEN_MASK;     // Asynchronous clock output disabled
   \   00000010   0x68C1             LDR      R1,[R0, #+12]
     90            if(adhsc == 1)
   \   00000012   0x2A01             CMP      R2,#+1
   \   00000014   0xF021 0x0108      BIC      R1,R1,#0x8
   \   00000018   0x60C1             STR      R1,[R0, #+12]
   \   0000001A   0x68C1             LDR      R1,[R0, #+12]
   \   0000001C   0xBF0C             ITE      EQ 
   \   0000001E   0xF041 0x0104      ORREQ    R1,R1,#0x4
   \   00000022   0xF021 0x0104      BICNE    R1,R1,#0x4
     91            {
     92              ADC_CFG2_REG(adc) |= ADC_CFG2_ADHSC_MASK;      // ¸ßËÙ×ª»»¶ÓÁÐÑ¡Ôñ
     93            }
     94            else
     95            {
     96              ADC_CFG2_REG(adc) &= ~ADC_CFG2_ADHSC_MASK;     // Õý³£×ª»»¶ÓÁÐÑ¡Ôñ
   \   00000026   0x60C1             STR      R1,[R0, #+12]
     97            }
     98            ADC_CFG2_REG(adc) |= ADC_CFG2_ADLSTS(adlsts);    // AD²ÉÑùÊ±¼äÑ¡Ôñ
   \   00000028   0x68C1             LDR      R1,[R0, #+12]
   \   0000002A   0xF003 0x0203      AND      R2,R3,#0x3
   \   0000002E   0x4311             ORRS     R1,R2,R1
   \   00000030   0x60C1             STR      R1,[R0, #+12]
     99          }
   \   00000032   0x4770             BX       LR               ;; return
    100          
    101          /*******************************************************************************
    102          * º¯ÊýÃû³Æ£ºADC_SetSC
    103          * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
    104                               ADC0_BASE_PTR
    105                               ADC1_BASE_PTR
    106                      avgs    Ó²¼þÂË²¨²ÉÑù´ÎÊýÑ¡Ôñ
    107                               00 4 samples averaged.
    108                               01 8 samples averaged.
    109                               10 16 samples averaged.
    110                               11 32 samples averaged.
    111                      aien    AD²ÉÑù½á¹û¶ÁÈ¡·½Ê½
    112                               0:²éÑ¯·½Ê½
    113                               1:ÖÐ¶Ï·½Ê½
    114                      prio    ÖÐ¶ÏÓÅÏÈ¼¶£¬Ö»ÔÚ aien=1 ÊÇÓÐÐ§
    115          * Ãè    Êö£ºÉèÖÃAD¼Ä´æÆ÷ ADCx_SCn
    116          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    117          void ADC_SetSC(ADC_MemMapPtr adc, int8u_t avgs, int8u_t aien, int8u_t prio)
    118          {
   \                     ADC_SetSC:
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x461C             MOV      R4,R3
    119            ADC_SC2_REG(adc) = 0;   // set default status:Software triger(a convertion is initated following a write to 
   \   00000004   0x2300             MOVS     R3,#+0
   \   00000006   0x6203             STR      R3,[R0, #+32]
    120                                    // SC1A)compare function disabled, DMA is disabled, default voltage reference pin(external pins VREFH and VREFL).
    121            ADC_SC3_REG(adc) |= ADC_SC3_ADCO_MASK            // Á¬Ðø×ª»»Ä£Ê½
    122                                + ADC_SC3_AVGE_MASK          // Ó²¼þÂË²¨Ê¹ÄÜ
    123                                + ADC_SC3_AVGS(avgs);        // ÉèÖÃÁ¬Ðø²ÉÑù´ÎÊý             
   \   00000008   0x6A43             LDR      R3,[R0, #+36]
   \   0000000A   0xF001 0x0103      AND      R1,R1,#0x3
   \   0000000E   0x310C             ADDS     R1,R1,#+12
   \   00000010   0x4319             ORRS     R1,R1,R3
   \   00000012   0x6241             STR      R1,[R0, #+36]
    124            if(aien == 1)
   \   00000014   0x2A01             CMP      R2,#+1
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0xD11A             BNE.N    ??ADC_SetSC_0
    125            {
    126              ADC_SC1_REG(adc,0)  |= ADC_SC1_AIEN_MASK;      // ÖÃÎ»ÖÐ¶ÏÊ¹ÄÜ¼Ä´æÆ÷
   \   0000001A   0xF041 0x0140      ORR      R1,R1,#0x40
   \   0000001E   0x6001             STR      R1,[R0, #+0]
    127              if(adc == ADC0_BASE_PTR)
   \   00000020   0x....             LDR.N    R1,??DataTable1  ;; 0x4003b000
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xD108             BNE.N    ??ADC_SetSC_1
    128              {
    129                EnableInt_Kinetis(57);
   \   00000026   0x2039             MOVS     R0,#+57
   \   00000028   0x.... 0x....      BL       EnableInt_Kinetis
    130                SetIntPri_Kinetis(57,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x2039             MOVS     R0,#+57
   \   00000034   0x.... 0x....      B.W      SetIntPri_Kinetis
    131              }
    132              else if(adc == ADC1_BASE_PTR)
   \                     ??ADC_SetSC_1:
   \   00000038   0x....             LDR.N    R1,??DataTable1_2  ;; 0x400bb000
   \   0000003A   0x4288             CMP      R0,R1
   \   0000003C   0xD10B             BNE.N    ??ADC_SetSC_2
    133              {
    134                EnableInt_Kinetis(58);
   \   0000003E   0x203A             MOVS     R0,#+58
   \   00000040   0x.... 0x....      BL       EnableInt_Kinetis
    135                SetIntPri_Kinetis(58,prio);                  // ÉèÖÃÖÐ¶ÏÓÅÏÈ¼¶
   \   00000044   0x4621             MOV      R1,R4
   \   00000046   0xE8BD 0x4010      POP      {R4,LR}
   \   0000004A   0x203A             MOVS     R0,#+58
   \   0000004C   0x.... 0x....      B.W      SetIntPri_Kinetis
    136              }
    137            }
    138            else
    139            {
    140              ADC_SC1_REG(adc,0)  &= ~ADC_SC1_AIEN_MASK;     // ²éÑ¯·½Ê½
   \                     ??ADC_SetSC_0:
   \   00000050   0xF021 0x0140      BIC      R1,R1,#0x40
   \   00000054   0x6001             STR      R1,[R0, #+0]
    141            }
    142          }
   \                     ??ADC_SetSC_2:
   \   00000056   0xBD10             POP      {R4,PC}          ;; return
    143          
    144          /*******************************************************************************
    145          * º¯ÊýÃû³Æ£ºADC_readResult
    146          * Èë¿Ú²ÎÊý£ºadc     AD×ª»»Æ÷Ñ¡Ôñ
    147                               ADC0_BASE_PTR
    148                               ADC1_BASE_PTR
    149                      channel AD²ÉÑùÍ¨µÀºÅ
    150                               00000 When DIFF=0, DADP0 is selected as input; when DIFF=1, DAD0 is selected as input.
    151                               00001 When DIFF=0, DADP1 is selected as input; when DIFF=1, DAD1 is selected as input.
    152                               00010 When DIFF=0, DADP2 is selected as input; when DIFF=1, DAD2 is selected as input.
    153                               00011 When DIFF=0, DADP3 is selected as input; when DIFF=1, DAD3 is selected as input.
    154                               00100 When DIFF=0, AD4 is selected as input; when DIFF=1, it is reserved.
    155                               00101 When DIFF=0, AD5 is selected as input; when DIFF=1, it is reserved.
    156                               00110 When DIFF=0, AD6 is selected as input; when DIFF=1, it is reserved.
    157                               00111 When DIFF=0, AD7 is selected as input; when DIFF=1, it is reserved.
    158                               01000 When DIFF=0, AD8 is selected as input; when DIFF=1, it is reserved.
    159                               01001 When DIFF=0, AD9 is selected as input; when DIFF=1, it is reserved.
    160                               01010 When DIFF=0, AD10 is selected as input; when DIFF=1, it is reserved.
    161                               01011 When DIFF=0, AD11 is selected as input; when DIFF=1, it is reserved.
    162                               01100 When DIFF=0, AD12 is selected as input; when DIFF=1, it is reserved.
    163                               01101 When DIFF=0, AD13 is selected as input; when DIFF=1, it is reserved.
    164                               01110 When DIFF=0, AD14 is selected as input; when DIFF=1, it is reserved.
    165                               01111 When DIFF=0, AD15 is selected as input; when DIFF=1, it is reserved.
    166                               10000 When DIFF=0, AD16 is selected as input; when DIFF=1, it is reserved.
    167                               10001 When DIFF=0, AD17 is selected as input; when DIFF=1, it is reserved.
    168                               10010 When DIFF=0, AD18 is selected as input; when DIFF=1, it is reserved.
    169                               10011 When DIFF=0, AD19 is selected as input; when DIFF=1, it is reserved.
    170                               10100 When DIFF=0, AD20 is selected as input; when DIFF=1, it is reserved.
    171                               10101 When DIFF=0, AD21 is selected as input; when DIFF=1, it is reserved.
    172                               10110 When DIFF=0, AD22 is selected as input; when DIFF=1, it is reserved.
    173                               10111 When DIFF=0, AD23 is selected as input; when DIFF=1, it is reserved.
    174                               11000 Reserved.
    175                               11001 Reserved.
    176                               11010 When DIFF=0, Temp sensor (single-ended) is selected as input; when DIFF=1, Temp sensor(differential) is selected as input.
    177                               11011 When DIFF=0, Bandgap (single-ended) is selected as input; when DIFF=1, Bandgap(differential) is selected as input.
    178                               11100 Reserved.
    179                               11101 When DIFF=0, VREFSH is selected as input; when DIFF=1, -VREFSH (differential) is selected asinput. 
    180                               11110 When DIFF=0, VREFSL is selected as input; when DIFF=1, it is reserved. Voltage referenceselected is determined by the REFSEL bits in the SC2 register.
    181                               11111 Module disabled.
    182                      result  AD²ÉÑù½á¹û
    183          * Ãè    Êö£º¶ÁÈ¡AD×ª»»½á¹û£¬Í¨¹ýÅäÖÃADÍ¨µÀ¿É¿ªÊ¼AD²ÉÑù
    184          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    185          void ADC_readResult(ADC_MemMapPtr adc,int8u_t channel, int16u_t * result)
    186          {
    187            int32u_t readReg = 0;
    188            
    189            readReg = ADC_SC1_REG(adc,0);
    190            readReg &= ~ADC_SC1_ADCH_MASK;
    191            readReg |= ADC_SC1_ADCH(channel);
    192            ADC_SC1_REG(adc,0) = readReg;                      // ÉèÖÃ ADC ²ÉÑùÍ¨µÀ
   \                     ADC_readResult:
   \   00000000   0x6803             LDR      R3,[R0, #+0]
   \   00000002   0xF361 0x0304      BFI      R3,R1,#+0,#+5
   \   00000006   0x6003             STR      R3,[R0, #+0]
    193            
    194            while(!(ADC_SC1_REG(adc,0)&ADC_SC1_COCO_MASK));    // µÈ´ý ADC ×ª»»½áÊø
   \                     ??ADC_readResult_0:
   \   00000008   0x6801             LDR      R1,[R0, #+0]
   \   0000000A   0x0609             LSLS     R1,R1,#+24
   \   0000000C   0xD5FC             BPL.N    ??ADC_readResult_0
    195            *result = ADC_R_REG(adc,0);                        // ¶ÁÈ¡ ADC ½á¹û¼Ä´æÆ÷£¬COCO ×Ô¶¯ÇåÁã
   \   0000000E   0x6900             LDR      R0,[R0, #+16]
   \   00000010   0x8010             STRH     R0,[R2, #+0]
    196          }
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4003B000         DC32     0x4003b000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x40048030         DC32     0x40048030

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x400BB000         DC32     0x400bb000

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC_ClockCtrl
        0  ADC_SetCFG1
        0  ADC_SetCFG2
        8  ADC_SetSC
             8 -> EnableInt_Kinetis
             0 -> SetIntPri_Kinetis
        0  ADC_readResult


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
      36  ADC_ClockCtrl
      34  ADC_SetCFG1
      52  ADC_SetCFG2
      88  ADC_SetSC
      20  ADC_readResult

 
 242 bytes in section .text
 
 242 bytes of CODE memory

Errors: none
Warnings: none
